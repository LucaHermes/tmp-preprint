<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0px;
            background: #d9d9dd;
            font-family: Arial, sans-serif;
            color: white;
        }
        #canvas-container {
            /* border: 2px solid #444; */
            display: inline-block;
        }
        h2 {
            margin-top: 0;
        }
        .info {
            margin-top: 20px;
            max-width: 800px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.1.5/dist/pixi.min.js"></script>
    <script src="./shader.js"></script>
    <script type="module" src="./metricGraph.js"></script>
    <script type="module" src="./readGraphData.js"></script>
    <script type="module" src="./inference.js"></script>
    <base href=".">
</head>
<body>
    <div id="canvas-container"></div>
    <script type="module">
        import { createMeshStrip, drawMetricGraph, drawInjectionControl, drawWDSSelectionControl } from './metricGraph.js';
        import { loadAllDefaultNPY, buildGraph } from './readGraphData.js';
        import { loadModel, runModel, getSegmentColor } from './inference.js';

        const { Application } = PIXI;

        const WDS = 0;
        const wdsNames = ["Hanoi", "l_town_no_tanks"];
        const wdsName = wdsNames[WDS];
        
        // Initialize PIXI application
        const app = new PIXI.Application();

        await app.init({
            resizeTo: window, // Make the canvas resize with the browser window
            antialiasing: true,
            backgroundColor: 0xd9d9dd,
            // antialias: true
        });

        document.getElementById('canvas-container').appendChild(app.canvas);
        
        
        let currentGraph = { 
            edgeMeshes: null,
            nodeGraphics: null, 
            model_inputs: null
        };
        let graphContainer = new PIXI.Container();
        let isSwitching = false;

        const edgeData = [];
        
        let time = 0;
        let lastTimeIdx = -1;
        let batchStarted = false;
        let lastEdgeData;
        let lastOut;
        let injLevel = 0.5;

        async function switchWDS(wdsName) {
            if (isSwitching) return;
            currentGraph.nodeGraphics = [];
            currentGraph = null;
            isSwitching = true;
            console.log(wdsName);
            app.stage.removeChild(graphContainer);
            graphContainer.destroy({ children : true });
            graphContainer = new PIXI.Container();
            currentGraph = await init(graphContainer, wdsName);
            app.stage.addChild(graphContainer);
            isSwitching = false;
            lastOut = undefined;
        } 

        async function init(container, wdsName) {
            const model_inputs = await loadAllDefaultNPY('default_model_inputs/default_inputs.json', wdsName);
            const graph = await buildGraph(model_inputs, wdsName);

            const WDS = wdsNames.indexOf(wdsName);
            const nodeSize = [50, 5][WDS];
            const edgeWidth = [60, 6][WDS];
            const numSegments = [60, 3][WDS];
            const timeScale = [0.3, 0.6][WDS];
            const Tau = 5; // [5, 5][WDS];
            const histSize = 30;

            const { edgeMeshes, nodeGraphics } = drawMetricGraph(
                container, graph, app.screen.width, app.screen.height, numSegments, nodeSize, edgeWidth
            );

            const modelFile = "mega_mp_" + wdsName + ".onnx";
            await loadModel(modelFile);

            return {
                edgeMeshes: edgeMeshes,
                nodeGraphics: nodeGraphics,
                model_inputs,
                graph,
                timeScale,
                wdsName,
                nodeSize,
                numSegments,
                Tau,
                histSize
            };
        }

        await switchWDS(wdsName);
        
        const {handle, slider} = drawInjectionControl(app, t => {
            injLevel = t;
        });

        drawWDSSelectionControl(app, 'hanoi_logo.png', 0, t => {
            switchWDS('Hanoi');
        });
        drawWDSSelectionControl(app, 'L-Town_logo.png', 140, t => {
            switchWDS('l_town_no_tanks');
        });
        


        let chlorineInjection = new Array(currentGraph.histSize + currentGraph.Tau).fill(0);

        app.ticker.add((delta) => {
            if (!currentGraph || !currentGraph.edgeMeshes || !currentGraph.nodeGraphics) return;

            time += delta.deltaTime * currentGraph.timeScale;
            
            const batchReady = edgeData.length != 0;
            const timeIdx = Math.floor(time % currentGraph.Tau);
            const T = Math.floor(time / currentGraph.Tau);

            if (lastTimeIdx == timeIdx) {
                return; // this frame was already rendered
            }
            lastTimeIdx = timeIdx;

            if (timeIdx == 0 && batchReady) {
                // console.log('New Batch!');
                lastEdgeData = edgeData.shift();
                batchStarted = false;
            }
            if (!batchReady && !batchStarted) { // batch not ready, start computing next
                lastOut = runModel(currentGraph.model_inputs, edgeData, T * currentGraph.Tau, lastOut, currentGraph.Tau, chlorineInjection, currentGraph.wdsName);
                batchStarted = true;
            }
            if (lastEdgeData === undefined) {
                return;
            }
            const batchIdx = Math.floor(time / currentGraph.Tau);
            const edgedata = lastEdgeData.data;
            
            chlorineInjection.shift();
            chlorineInjection.push(injLevel);
            
            // animate
            for (const edgeIdx in currentGraph.edgeMeshes) {
                const edgemesh = currentGraph.edgeMeshes[edgeIdx];
                const colorBuffer = edgemesh.geometry.getBuffer('aColor');
                // color is 1080 long if 60 segments: 
                // 60 [segs] * 2 [triangles] * 3 [points] * 3 [RGB]
                
                const colors = colorBuffer.data;
                for (let i = 0; i < colors.length; i += 3) {
                    const segIdx = Math.floor(i/(2*3*3));
                    const c = getSegmentColor(lastEdgeData, edgeIdx, segIdx, timeIdx).gl();
                    colors[i]   = c[0];
                    colors[i+1] = c[1];
                    colors[i+2] = c[2];
                }
                colorBuffer.update();
                const s = currentGraph.graph.edges[edgeIdx].s;
                const t = currentGraph.graph.edges[edgeIdx].t;
                currentGraph.nodeGraphics[s].clear();                 // clear previous drawing
                currentGraph.nodeGraphics[s].beginFill(getSegmentColor(
                    lastEdgeData, edgeIdx, 0, timeIdx).hex());     // new color
                currentGraph.nodeGraphics[s].circle(0, 0, currentGraph.nodeSize);
                currentGraph.nodeGraphics[s].endFill();

                currentGraph.nodeGraphics[t].clear();                 // clear previous drawing
                currentGraph.nodeGraphics[t].beginFill(getSegmentColor(
                    lastEdgeData, edgeIdx, currentGraph.numSegments-1, timeIdx).hex());     // new color
                currentGraph.nodeGraphics[t].circle(0, 0, currentGraph.nodeSize);
                currentGraph.nodeGraphics[t].endFill();
            }
        });

    </script>
</body>
</html>